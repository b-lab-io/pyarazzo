# ruff: noqa

# generated by datamodel-codegen:
#   filename:  schema.yaml
#   timestamp: 2024-12-07T14:24:13+00:00

from __future__ import annotations

from abc import ABC, abstractmethod
from enum import Enum
from typing import Annotated, Any, Dict, List, Optional, Union

from pydantic import AnyUrl, BaseModel, Field, RootModel

from pyarazzo.utils import load_spec


class ArazzoVisitor(ABC):
    @abstractmethod
    def visit_specification(self, instance: ArazzoSpecification):
        pass

  

    @abstractmethod
    def visit_workflow(self, instance: Workflow):
        pass

    @abstractmethod
    def visit_step(self, instance: Step):
        pass

    @abstractmethod
    def visit_components(self, instance: ComponentsObject):
        pass

    @abstractmethod
    def visit_info(self, instance: Info):
        pass
    @abstractmethod
    def visit_source_decription(self, instance: SourceDescriptionObject):
        pass
    @abstractmethod
    def visit_criterion_expression_type(self, instance: CriterionExpressionTypeObject):
        pass
    @abstractmethod
    def visit_reusable(self, instance: ReusableObject):
        pass
    @abstractmethod
    def visit_parameter(self, instance: ParameterObject):
        pass
    @abstractmethod
    def visit_payload_replacement(self, instance: PayloadReplacementObject):
        pass
    @abstractmethod
    def visit_meta_data(self, instance: MetaData):
        pass

class ArazzoElement(BaseModel):
    """Base class for all Arazzo elements."""

    @abstractmethod
    def accept(self, visitor: ArazzoVisitor):
        """Accept a visitor to process this element."""


class Info(ArazzoElement):
    title: Annotated[
        str,
        Field(description="A human readable title of the Arazzo Description"),
    ]
    summary: Annotated[
        Optional[str],
        Field(description="A short summary of the Arazzo Description"),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="A description of the purpose of the workflows defined. CommonMark syntax MAY be used for rich text representation",
        ),
    ] = None
    version: Annotated[
        str,
        Field(
            description="The version identifier of the Arazzo document (which is distinct from the Arazzo Specification version)",
        ),
    ]

    def accept(self, visitor: ArazzoVisitor):
        return visitor.visit_info(self)


class SourceType(str, Enum):
    arazzo = "arazzo"
    openapi = "openapi"


class SourceDescriptionObject(ArazzoElement):
    
    name: Annotated[
        str,
        Field(
            description="A unique name for the source description",
            pattern=r"^[A-Za-z0-9_\\-]+$",
        ),
    ]
    url: Annotated[
        str,
        Field(description="A URL to a source description to be used by a workflow"),
    ]
    type: Annotated[
        Optional[SourceType],
        Field(description="The type of source description"),
    ] = None

    def accept(self, visitor: ArazzoVisitor):
        return visitor.visit_source_decription(self)


class Type1(Enum):
    jsonpath = "jsonpath"
    xpath = "xpath"


class CriterionExpressionTypeObject(ArazzoElement):
    type: Annotated[Type1, Field(description="The type of condition to be applied")]
    version: Annotated[
        str,
        Field(
            description="A short hand string representing the version of the expression type",
        ),
    ]

    def accept(self, visitor: ArazzoVisitor):
        return visitor.visit_criterion_expression_type(self)


class Type2(str, Enum):
    end = "end"
    goto = "goto"


class Type3(str, Enum):
    end = "end"
    goto = "goto"
    retry = "retry"


class ReusableObject(ArazzoElement):
    reference: Annotated[
        str,
        Field(description="A runtime expression used to reference the desired object"),
    ]
    value: Annotated[
        Optional[Union[str, bool, Dict[str, Any], List[Any], float]],
        Field(description="lists a value of the referenced parameter"),
    ] = None

    def accept(self, visitor: ArazzoVisitor):
        return visitor.visit_reusable(self)


class In(str, Enum):
    path = "path"
    query = "query"
    header = "header"
    cookie = "cookie"
    body = "body"


class ParameterObject(ArazzoElement):
    name: Annotated[str, Field(description="The name of the parameter")]
    in_: Annotated[
        Optional[In],
        Field(alias="in", description="The named location of the parameter"),
    ] = None
    value: Annotated[
        Optional[Union[str, bool, Dict[str, Any], List[Any], float]],
        Field(description="The value to pass in the parameter"),
    ]

    def accept(self, visitor: ArazzoVisitor):
        return visitor.visit_parameter(self)


class PayloadReplacementObject(ArazzoElement):
    target: Annotated[
        str,
        Field(
            description="A JSON Pointer or XPath Expression which MUST be resolved against the request body",
        ),
    ]
    value: Annotated[
        str, Field(description="The value list within the target location")
    ]

    def accept(self, visitor: ArazzoVisitor):
        return visitor.visit_payload_replacement(self)


class SpecificationExtensions(RootModel):
    root: Annotated[
        Any,
        Field(
            description="While the Arazzo Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points",
        ),
    ]


class AnchorString(RootModel):
    root: Annotated[str, Field(pattern=r"^[A-Za-z_][-A-Za-z0-9._]*$")]


class UriString(RootModel):
    root: AnyUrl


class UriReferenceString(RootModel):
    root: str


class SchemaArray(RootModel):
    root: Annotated[List[Any], Field(min_length=1)]


class Unevaluate(BaseModel):
    unevaluatedItems: Optional[Any] = None
    unevaluatedProperties: Optional[Any] = None


class NonNegativeInteger(RootModel):
    root: Annotated[int, Field(ge=0)]


class NonNegativeIntegerDefault0(RootModel):
    root: NonNegativeInteger


class SimpleTypes(str, Enum):
    array = "array"
    boolean = "boolean"
    integer = "integer"
    null = "null"
    number = "number"
    object = "object"
    string = "string"


class StringArray(RootModel):
    root: Annotated[list[str], Field()]


class MetaData(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    default: Optional[Any] = None
    deprecated: Optional[bool] = False
    readOnly: Optional[bool] = False
    writeOnly: Optional[bool] = False
    examples: Optional[List] = None

    def accept(self, visitor: ArazzoVisitor):
        return visitor.visit_meta_data(self)


class FormatAnnotatio(BaseModel):
    format: Optional[str] = None


class Conten(BaseModel):
    contentEncoding: Optional[str] = None
    contentMediaType: Optional[str] = None
    contentSchema: Optional[Any] = None


class StepId(RootModel):
    root: Any


class WorkflowId(RootModel):
    root: Any


class RequestBodyObject(BaseModel):
    contentType: Annotated[
        Optional[str],
        Field(description="The Content-Type for the request content"),
    ] = None
    payload: Optional[Any] = None
    # replacements: Annotated[
    #     Optional[list[PayloadReplacementObject]],
    #     Field(
    #         description='A list of locations and values to list within a payload',
    #     ),
    # ] = None


class CriterionObject(RootModel):
    root: Annotated[
        SpecificationExtensions,
        Field(
            description="An object used to specify the context, conditions, and condition types\nthat can be used to prove or satisfy assertions specified in Step Object successCriteria,\nSuccess Action Object criteria, and Failure Action Object criteria",
        ),
    ]


class SuccessActionObject(BaseModel):
    name: Annotated[str, Field(description="The name of the success action")]
    type: Annotated[Type2, Field(description="The type of action to take")]
    workflowId: Annotated[
        Optional[WorkflowId],
        Field(
            description="The workflowId referencing an existing workflow within the Arazzo description to transfer to upon success of the step",
        ),
    ] = None
    stepId: Annotated[
        Optional[StepId],
        Field(description="The stepId to transfer to upon success of the step"),
    ] = None
    criteria: Annotated[
        Optional[list[CriterionObject]],
        Field(
            description="A list of assertions to determine if this action SHALL be executed",
            min_length=1,
        ),
    ] = None


class FailureActionObject(BaseModel):
    name: Annotated[str, Field(description="The name of the failure action")]
    type: Annotated[Type3, Field(description="The type of action to take")]
    workflowId: Annotated[
        Optional[WorkflowId],
        Field(
            description="The workflowId referencing an existing workflow within the Arazzo description to transfer to upon failure of the step",
        ),
    ] = None
    stepId: Annotated[
        Optional[StepId],
        Field(description="The stepId to transfer to upon failure of the step"),
    ] = None
    retryAfter: Annotated[
        Optional[float],
        Field(
            description="A non-negative decimal indicating the seconds to delay after the step failure before another attempt SHALL be made",
            ge=0.0,
        ),
    ] = None
    retryLimit: Annotated[
        Optional[int],
        Field(
            description="A non-negative integer indicating how many attempts to retry the step MAY be attempted before failing the overall step",
            ge=0,
        ),
    ] = None
    criteria: Annotated[
        Optional[list[CriterionObject]],
        Field(
            description="A list of assertions to determine if this action SHALL be executed",
        ),
    ] = None


class Cor(BaseModel):
    field_id: Annotated[Optional[UriReferenceString], Field(alias="$id")] = None
    field_schema: Annotated[Optional[UriString], Field(alias="$schema")] = None
    field_ref: Annotated[Optional[UriReferenceString], Field(alias="$ref")] = None
    field_anchor: Annotated[Optional[AnchorString], Field(alias="$anchor")] = None
    field_dynamicRef: Annotated[
        Optional[UriReferenceString],
        Field(alias="$dynamicRef"),
    ] = None
    field_dynamicAnchor: Annotated[
        Optional[AnchorString],
        Field(alias="$dynamicAnchor"),
    ] = None
    field_vocabulary: Annotated[
        Optional[Dict[str, bool]],
        Field(alias="$vocabulary"),
    ] = None
    field_comment: Annotated[Optional[str], Field(alias="$comment")] = None
    field_defs: Annotated[Optional[Dict[str, Any]], Field(alias="$defs")] = None


class Applicato(BaseModel):
    prefixItems: Optional[SchemaArray] = None
    items: Optional[Any] = None
    contains: Optional[Any] = None
    additionalProperties: Optional[Any] = None
    properties: Optional[Dict[str, Any]] = {}
    patternProperties: Optional[Dict[str, Any]] = {}
    dependentSchemas: Optional[Dict[str, Any]] = {}
    propertyNames: Optional[Any] = None
    if_: Annotated[Optional[Any], Field(alias="if")] = None
    then: Optional[Any] = None
    else_: Annotated[Optional[Any], Field(alias="else")] = None
    allOf: Optional[SchemaArray] = None
    anyOf: Optional[SchemaArray] = None
    oneOf: Optional[SchemaArray] = None
    not_: Annotated[Optional[Any], Field(alias="not")] = None


class Type4(RootModel):
    root: Annotated[list[SimpleTypes], Field(min_length=1)]


class Validatio(BaseModel):
    type: Optional[Union[SimpleTypes, Type4]] = None
    const: Optional[Any] = None
    enum: Optional[List] = None
    multipleOf: Annotated[Optional[float], Field(gt=0.0)] = None
    maximum: Optional[float] = None
    exclusiveMaximum: Optional[float] = None
    minimum: Optional[float] = None
    exclusiveMinimum: Optional[float] = None
    maxLength: Optional[NonNegativeInteger] = None
    minLength: Optional[NonNegativeIntegerDefault0] = None
    pattern: Optional[str] = None
    maxItems: Optional[NonNegativeInteger] = None
    minItems: Optional[NonNegativeIntegerDefault0] = None
    uniqueItems: Optional[bool] = False
    maxContains: Optional[NonNegativeInteger] = None
    minContains: Annotated[Optional[int], Field(ge=0)] = 1
    maxProperties: Optional[NonNegativeInteger] = None
    minProperties: Optional[NonNegativeIntegerDefault0] = None
    required: Optional[StringArray] = None
    dependentRequired: Optional[Dict[str, StringArray]] = None


class Step(ArazzoElement):
    stepId: Annotated[str, Field(description="Unique string to represent the step")]
    description: Annotated[
        Optional[str],
        Field(
            description="A description of the step. CommonMark syntax MAY be used for rich text representation",
        ),
    ] = None
    operationId: Annotated[
        Optional[str],
        Field(
            description="The name of an existing, resolvable operation, as defined with a unique operationId and existing within one of the sourceDescriptions",
        ),
    ] = None
    operationPath: Annotated[
        Optional[str],
        Field(
            description="A reference to a Source combined with a JSON Pointer to reference an operation",
        ),
    ] = None
    workflowId: Annotated[
        Optional[WorkflowId],
        Field(
            description="The workflowId referencing an existing workflow within the Arazzo description",
        ),
    ] = None
    parameters: Annotated[
        Optional[list],
        Field(
            description="A list of parameters that MUST be passed to an operation or workflow as referenced by operationId, operationPath, or workflowId",
        ),
    ] = None
    requestBody: Optional[RequestBodyObject] = None
    successCriteria: Annotated[
        Optional[list[CriterionObject]],
        Field(
            description="A list of assertions to determine the success of the step",
            min_length=1,
        ),
    ] = None
    onSuccess: Annotated[
        Optional[list[Union[SuccessActionObject, ReusableObject]]],
        Field(
            description="An array of success action objects that specify what to do upon step success",
        ),
    ] = None
    onFailure: Annotated[
        Optional[list[Union[FailureActionObject, ReusableObject]]],
        Field(
            description="An array of failure action objects that specify what to do upon step failure",
        ),
    ] = None
    outputs: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="A map between a friendly name and a dynamic output value defined using a runtime expression",
        ),
    ] = None

    def accept(self, visitor: ArazzoVisitor):
        return visitor.visit_step(self)


class Schem(Cor, Applicato, Unevaluate, Validatio, MetaData, FormatAnnotatio, Conten):
    definitions: Optional[Dict[str, Any]] = {}
    dependencies: Optional[Dict[str, Union[Any, StringArray]]] = {}
    field_recursiveAnchor: Annotated[
        Optional[AnchorString],
        Field(alias="$recursiveAnchor"),
    ] = None
    field_recursiveRef: Annotated[
        Optional[UriReferenceString],
        Field(alias="$recursiveRef"),
    ] = None


class Schema(RootModel):
    root: Schem


class Workflow(ArazzoElement):
    workflowId: Annotated[
        str,
        Field(description="Unique string to represent the workflow"),
    ]
    summary: Annotated[
        Optional[str],
        Field(description="A summary of the purpose or objective of the workflow"),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="A description of the workflow. CommonMark syntax MAY be used for rich text representation",
        ),
    ] = None
    inputs: Annotated[
        Optional[Schema],
        Field(
            description="A JSON Schema 2020-12 object representing the input parameters used by this workflow",
        ),
    ] = None
    dependsOn: Annotated[
        Optional[list[str]],
        Field(
            description="A list of workflows that MUST be completed before this workflow can be processed",
        ),
    ] = None
    steps: Annotated[
        list[Step],
        Field(
            description="An ordered list of steps where each step represents a call to an API operation or to another workflow",
            min_length=1,
        ),
    ]
    successActions: Annotated[
        Optional[list[Union[SuccessActionObject, ReusableObject]]],
        Field(
            description="A list of success actions that are applicable for all steps described under this workflow",
        ),
    ] = None
    failureActions: Annotated[
        Optional[list[Union[FailureActionObject, ReusableObject]]],
        Field(
            description="A list of failure actions that are applicable for all steps described under this workflow",
        ),
    ] = None
    outputs: Annotated[
        Optional[Dict[str, Any]],
        Field(description="A map between a friendly name and a dynamic output value"),
    ] = None
    parameters: Annotated[
        Optional[List[Union[ParameterObject, ReusableObject]]],
        Field(
            description="A list of parameters that are applicable for all steps described under this workflow",
        ),
    ] = None

    def accept(self, visitor: ArazzoVisitor):
        return visitor.visit_workflow(self)


class ComponentsObject(ArazzoElement):
    inputs: Annotated[
        Optional[Dict[str, Schema]],
        Field(
            description="An object to hold reusable JSON Schema 2020-12 schemas to be referenced from workflow inputs",
        ),
    ] = None
    parameters: Annotated[
        Optional[Dict[str, ParameterObject]],
        Field(description="An object to hold reusable Parameter Objects"),
    ] = None
    successActions: Annotated[
        Optional[Dict[str, SuccessActionObject]],
        Field(description="An object to hold reusable Success Actions Objects"),
    ] = None
    failureActions: Annotated[
        Optional[Dict[str, FailureActionObject]],
        Field(description="An object to hold reusable Failure Actions Objects"),
    ] = None

    def accept(self, visitor: ArazzoVisitor):
        return visitor.visit_components(self)


class ArazzoSpecification(ArazzoElement):
    """This is the root object of the Arazzo Description."""
    arazzo: Annotated[
        str,
        Field(
            description="The version number of the Arazzo Specification",
            pattern=r"^1\.0\.\d+(-.+)?$",
        ),
    ]
    info: Info
    source_descriptions: Annotated[
        list[SourceDescriptionObject],
        Field(
            description="A list of source descriptions such as Arazzo or OpenAPI",
            min_length=1,
            alias="sourceDescriptions",
        ),
    ]
    workflows: Annotated[
        list[Workflow],
        Field(description="A list of workflows", min_length=1),
    ]
    components: Optional[ComponentsObject] = None

    def accept(self, visitor: ArazzoVisitor)-> None:
        """Allows an Arazzo visitor to traverse the instance.

        Args:
            visitor (ArazzoVisitor): instance of an Arazzo visitor

        """
        return visitor.visit_specification(self)


class ArazzoSpecificationLoader:
    """Helper class to load an Arazzo specific ation from a file or URL."""
    @staticmethod
    def load(path_or_url: str) -> ArazzoSpecification:
        """Load and arazzo specification.

        Args:
            path_or_url (str): url or path

        Returns:
            ArazzoSpecification: _description_
        """
        spec_dict = load_spec(path_or_url)
        return ArazzoSpecification(**spec_dict)
